main:   irmovq		stack, %rsp
		irmovq 		array, %rdi
    	irmovq 		$8, %rsi
		irmovq		$5, %r14
		call 		sum        	# sum(array, 4)
		irmovq 		arrayX, %rdi
		call 		rproduct
		irmovq 		arrayY, %rdi
		call 		abssum
		irmovq 		arrayZ, %rdi
		call 		csloop
		call 		OLoop
		isubq		$1, %r14
		jge			main
		halt
	
# long sum(long *start, long count)
# start in %rdi, count in %rsi
sum:    irmovq 		$8, %r8        # Constant 8
		irmovq 		$12, %r9        # Constant 1
    	xorq 		%rax, %rax       # sum = 0
		andq 		%rsi, %rsi       # Set CC
		jmp     	test         # Goto test
loop:   mrmovq 		(%rdi), %r10   # Get *start
    	addq 		%r10, %rax       # Add to sum
    	addq 		%r8, %rdi        # start++
		isubq 		$1, %r9        # count--.  Set CC
test:  
		jge    		loop          # Stop when 0
		ret                  # Return

	# long rproduct(long *start, long count)
	# start in %rdi, count in %rsi
rproduct:
		irmovq 		$-1, %r10
		irmovq		$24, %rsi
recompute:
		xorq 		%rax, %rax 	# Set return value to 1
		andq 		%rsi, %rsi 	# Set condition codes
		je 			return		 # If count <= 0, return 1
		mrmovq 		(%rdi), %rbx 	# Get *start
		addq 		%r10, %rsi	 # count--
		irmovq 		$8, %rdi
		addq		%rbx, %rax 	# add (originally multiply)
		addq 		%r10, %rsi 	# start++
		jge 		recompute   # Restore callee-saved register
return:
		ret

# long absSum(long *start, long count)
# start in %rdi, count in %rsi
abssum:
		irmovq 		$8, %r8 	# Constant 8
		irmovq 		$1, %r9 	# Constant 1
		irmovq 		$12, %rsi 	# Constant 1
		xorq 		%rax, %rax 	# sum = 0
		andq 		%rsi, %rsi 	# Set condition codes
		jmp 		astest
asloop:
		mrmovq 		(%rdi), %r10 	# x = *start
		xorq 		%r11, %r11 	# Constant 0
		subq 		%r10, %r11 	# -x
		jle 		pos 		# Skip if -x <= 0
		rrmovq 		%r11, %r10 	# x = -x
pos:
		addq 		%r10, %rax 	# Add to sum
		addq 		%r8, %rdi 	# start++
		subq 		%r9, %rsi 	# count--
astest:
		jge 		asloop 		# Stop when 0
		ret

csloop:
		irmovq 		$25, %rsi 	# Con
again:
		mrmovq 		(%rdi), %r10 	# x = *start
		xorq 		%r11, %r11 	# Constant 0
		subq 		%r10, %r11 	# -x
		cmovg 		%r11, %r10 	# If -x > 0 then x = -x
		addq 		%r10, %rax 	# Add to sum
		addq 		%r8, %rdi 	# start++
		subq 		%r9, %rsi 	# count--
		jge		 	again 	# Stop when 0

	# Code to generate a combination of not-taken branch and ret
		irmovq 		$200, %rax
		isubq 		$2, %rax 	# Set Z condition code
		jge 		target 		# Not taken (First part of combination)
		irmovq 		$1, %rax 	# Should execute this
		ret
target: 
		irmovq 		$2, %rbx	 # Should not execute this
		irmovq 		$5, %rcx
		irmovq 		$7, %rdx 	# Should not execute this
rtpt:	isubq 		$1, %rdx 	# Should not execute this
		addq		%rcx, %rbx
		jle			rtpt
		ret
newprog:
		irmovq	    arrayX, %rdx
		irmovq	    arrayY, %rax
		irmovq 		arrayZ, %rbp
		irmovq		$6, %r10 
OLoop:	irmovq 		$5, %rsi
ILoop:	mrmovq		0(%rdx), %rcx
		mrmovq		0(%rax), %rbx
		addq		%rcx, %rbx
		rmmovq		%rcx, 0(%rbp)
		iaddq		$8, %rdx
		iaddq		$8, %rax
		isubq		$1, %rsi
		jge			ILoop
		iaddq		$40, %rdx
		iaddq		$40, %rax
		iaddq		$8, %rbp
		isubq		$1, %r10
		jge			OLoop
		ret
		nop
		nop
# Array of 4 elements
    .align 8
array:  
		.quad 0x400000000000
		.quad 0x410000000000
		.quad 0x420000000000
		.quad 0x430000000000
		.quad 0x440000000000
		.quad 0x450000000000
		.quad 0x460000000000
		.quad 0x470000000000
		.quad 0x480000000000
		.quad 0x490000000000
		.quad 0x4a0000000000
		.quad 0x4b0000000000
		.quad 0x4c0000000000		
		.quad 0x4d0000000000
		.quad 0x4e0000000000
		.quad 0x4f0000000000		

.pos 0x0700
arrayX:
		.quad 0x000000000000
		.quad 0x010000000000
		.quad 0x020000000000
		.quad 0x030000000000
		.quad 0x040000000000
		.quad 0x050000000000
		.quad 0x060000000000
		.quad 0x070000000000
		.quad 0x080000000000
		.quad 0x090000000000
		.quad 0x0a0000000000
		.quad 0x0b0000000000
		.quad 0x0c0000000000		
		.quad 0x0d0000000000
		.quad 0x0e0000000000
		.quad 0x0f0000000000		
		.quad 0x100000000000
		.quad 0x110000000000
		.quad 0x120000000000
		.quad 0x130000000000
		.quad 0x140000000000
		.quad 0x150000000000
		.quad 0x160000000000
		.quad 0x170000000000
		.quad 0x180000000000
		.quad 0x190000000000
		.quad 0x1a0000000000
		.quad 0x1b0000000000
		.quad 0x1c0000000000		
		.quad 0x1d0000000000
		.quad 0x1e0000000000
		.quad 0x1f0000000000		
.pos 0x0A00
arrayY:
		.quad 0x200000000000
		.quad 0x210000000000
		.quad 0x220000000000
		.quad 0x230000000000
		.quad 0x240000000000
		.quad 0x250000000000
		.quad 0x260000000000
		.quad 0x270000000000
		.quad 0x280000000000
		.quad 0x290000000000
		.quad 0x2a0000000000
		.quad 0x2b0000000000
		.quad 0x2c0000000000		
		.quad 0x2d0000000000
		.quad 0x2e0000000000
		.quad 0x2f0000000000		
		.quad 0x300000000000
		.quad 0x310000000000
		.quad 0x320000000000
		.quad 0x330000000000
		.quad 0x340000000000
		.quad 0x350000000000
		.quad 0x360000000000
		.quad 0x370000000000
		.quad 0x380000000000
		.quad 0x390000000000
		.quad 0x3a0000000000
		.quad 0x3b0000000000
		.quad 0x3c0000000000		
		.quad 0x3d0000000000
		.quad 0x3e0000000000
		.quad 0x3f0000000000		
.pos 0x0D00
arrayZ:
		.quad 0x400000000000
		.quad 0x410000000000
		.quad 0x420000000000
		.quad 0x430000000000
		.quad 0x440000000000
		.quad 0x450000000000
		.quad 0x460000000000
		.quad 0x470000000000
		.quad 0x480000000000
		.quad 0x490000000000
		.quad 0x4a0000000000
		.quad 0x4b0000000000
		.quad 0x4c0000000000		
		.quad 0x4d0000000000
		.quad 0x4e0000000000
		.quad 0x4f0000000000		
		.quad 0x500000000000
		.quad 0x510000000000
		.quad 0x520000000000
		.quad 0x530000000000
		.quad 0x540000000000
		.quad 0x550000000000
		.quad 0x560000000000
		.quad 0x570000000000
		.quad 0x580000000000
		.quad 0x590000000000
		.quad 0x5a0000000000
		.quad 0x5b0000000000
		.quad 0x5c0000000000		
		.quad 0x5d0000000000
		.quad 0x5e0000000000
		.quad 0x5f0000000000		
stack:	
	.quad 0x100000000000
	.quad 0x100000000000
	.quad 0x100000000000
	.quad 0x100000000000
	