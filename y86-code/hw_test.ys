# address 0
#
    .pos 0
    irmovq stack, %rsp
    call main
    halt

.pos 0x100
main:
    # rdi now contains the array
    irmovq $array, %rdi
    irmovq $72, %r14

    # array starts at the last element
    addq %r14, %rdi

    # X = 40
    irmovq $40, %rsi

    # S = 0
    irmovq $0, %r8

    # Limit = 3000
    irmovq $3000, %rdx

    # i = size - 1
    irmovq $9, %rcx

    # amt to increment array by 
    irmovq $8, %r14
loop:
    # check if i < 0
    rrmovq %rcx, %r11
    tjlt %r11, done

    # load A[i] into %rbx
    mrmovq (%rdi), %rbx

    # i--
    subq %r14, %rdi
    irmovq $1, %rax
    subq %rax, %rcx

    # if (A[i] < 0)
    rrmovq %rbx, %r11

    # jump if negative
    tjlt %r11, neg_case

pos_case:
    # Y = X >> A[i]

    # x moves into y
    rrmovq %rsi, %r9

    # shift amt (A[i])
    rrmovq %rbx, %r10

    # Y = X >> A[i]
    shaq %r10, %r9
    jmp compute_mod 

neg_case:
    # Y = X << (-A[i])

    # x moves into y
    rrmovq %rsi, %r9

    # shift amt (A[i])
    rrmovq %rbx, %r10

    irmovq $0, %r11

    # r11 = -A[i]
    subq %r10, %r11

    # Y = X << (-A[i])
    shaq %r11, %r9

compute_mod:
    rrmovq %r9, %r12
    divq %rdx, %r12
    mulq %rdx, %r12
    subq %r12, %r9
    
    tjge %r9, no_adjust
    addq %rdx, %r9
no_adjust:
    
    addq %r9, %r8          # S += remainder

    jmp loop

done:
    ret


#int A[size]
    .pos 0x200
    .align 8
array: .quad -4
    .quad -13
    .quad 3
    .quad 1
    .quad -2
    .quad -5
    .quad -1
    .quad 0
    .quad -7
    .quad 3 

	.pos 0x300
stack:
